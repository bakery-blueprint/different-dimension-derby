# 응용 서비스와 표현 영역

## 표현 영역과 응용 영역

도메인이 제 기능을 하려면 사용자와 도메인을 연결해 주는 매개체가 필요
사용자 -> 표현 영역 -> 응용 영역 -> 도메인 영역

표현 영역 : 사용자의 요청을 해석. URL, 요청 파라미터, 쿠키, 헤더 등을 이용해서 사용자가 어떤 기능을 실행하고 싶어하는지 판별
응용 영역 : 실제 사용자가 원하는 기능을 제공

응용 서비스의 메서드가 요구하는 parameter ≠ 표현 영역이 사용자로부터 전달받은 데이터
표현 영역은 응용 서비스가 요구하는 형식으로 사용자 요청을 변환

사용자와의 상호작용은 표현 영역이 처리하기 때문에, 응용 영역은 기능 실행에 필요한 입력값을 전달받고 실행 결과만 리턴

## 응용 서비스의 역할
사용자(클라이언트)가 요청한 기능을 실행

요청 처리를 위해 리포지터리로 부터 도메인 객체를 구하고, 도메인 객체를 사용
1. 리포지터리에서 애그리거트를 구한다
2. 애그리거트의 도메인 기능을 실행한다
3. 결과를 리턴한다

데이터를 신규로 생성하는 case
1. 데이터 중복 등 데이터 유효성 검사
2. 애그리거트 생성
3. 리포지터리에 애그리거트 저장
4. 결과 리턴

응용 서비스가 이것보다 복잡하다면 도메인 로직의 일부를 구현하고 있을 가능성이 높음

응용 서비스의 주된 역할 중 트랜잭션 처리, 접근 제어, 이벤트 처리 등이 있음 (뒤에서 나올 내용)

### 도메인 로직 넣지않기
도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생
1. 코드의 응집성이 떨어짐
   도메인 로직을 파악하기 위해 여러 영역을 분석해야함
2. 여러 응용서비스에서 동일한 도메인 로직을 구현할 가능성이 높아짐
   코드 중복 문제


## 응용 서비스의 구현
표현 영역과 도메인 영역을 연결하는 매개체 역할
-> 디자인 패턴에서 facade 역할

#### 응용 서비스의 크기
* 한 응용 서비스 클래스에 관련 도메인의 모든 기능 구현하기
    * 각 기능에서 동일 로직에 대한 코드 중복을 제거할 수 있음 (장점)
    * 한 서비스 클래스의 크기가 커진다 (단점)
* 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기
    * 한 응용 서비스 클래스에서 햔개 내지 2~3개 기능을 구현
    * 클래스 개수는 많아지지만 코드 품질을 일정 수준으로 유지하는데 도움
    * 여러 클래스에 중복해서 동일한 코드를 구현할 가능성 (단점)
        * 별도 클래스에 로직을 구현해서 중복 방지 (Helper)

#### 응용 서비스의 인터페이스와 클래스
응용 서비스를 구현할 때 인터페이스를 만들고 이를 상속한 클래스를 만드는 것이 필요할까?
구현 클래스가 여러개이거나 런타임에 구현 객체를 교체해야하는 경우는 인터페이스 사용이 유용함

인터페이스가 명확하게 필요하기 전까지는 응용 서비스에 대한 인터페이스를 작성하는 것이 좋은 설계라고 볼 수 없음

tdd를 즐겨하는 케이스면 표현 영역부터 시작하여 응용서비스 구체단까지 오기전에 인터페이스 구현으로 대체하는데
mockito를 이용해서 mocking하는 것을 더 추천

#### 메서드 파라미터와 값 리턴
개별 parameter로 받을 수도 있고, 값 전달을 위한 별도 데이터 클래스를 만들어 전달받을 수도 있음
웹 프레임워크는 요청 parameter를 자바 객체로 변환하여 받을 수 있는 기능을 제공하므로 파라미터가 두개 이상인 경우 별도 클래스를 사용하는 것이 편리

응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법

#### 표현 영역에 의존하지 않기
응용 서비스의 파라미터 타입을 결정할때 표현 영역과 관련된 타입을 사용하면 안됨 (ex. HttpServletRequest, HttpSession)
응용 서비스에서 표현 영역에 대한 의존이 발생하면 응용 서비스만 단독으로 테스트하기가 어려워짐

#### 트랜잭션 처리
프레임워크가 제공하는 트랜잭션 기능을 적극 사용 (ex. @Transactional)
규칙을 따르면 간단한 설정만으로 트랜잭션 시작, 커밋, 롤백

#### 도메인 이벤트 처리
응용 서비스의 역할 중 하나는 도메인 영역에서 발생시킨 이벤트(도메인에서 발생한 상태 변경)를 처리하는 것
이벤트를 받아서 이벤트에 알맞은 후처리를 함

이벤트를 사용하면 코드가 다소 복잡해지는 대신 도메인 간의 의존성이나 외부 시스템에 대한 의존을 낮춰주는 장점
(자세한 내용은 10, 11장에서)



## 표현 영역
표현 영역의 책임
* 사용자가 시스템을 사용할 수 있는 (화면) 흐름을 제공하고 제어
* 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공
    * 사용자의 요청 데이터를 응용 서비스가 요구하는 형식으로 변환하고, 응용 서비스의 결과를 사용자에게 응답할 수 있는 형식으로 변환
* 사용자의 세션 관리



## 값 검증
표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있음
원칙적으로는 값에 대한 검증은 응용 서비스에서 처리

Validator 같은 검증을 통해 표현영역에서 1차적 검증 후 논리적 오류는 응용 서비스 단에서 검사

* 표현 영역 : 필수값, 값의 형식, 범위 등을 검증
* 응용 서비스 : 데이터의 존재 유무와 같은 논리적 오류를 검증

응용 서비스를 실행하는 주체가 표현 영역이면 응용 서비스는 논리적 오류 위주로 값을 검증해도 문제가 없음
하지만, 실행 주체가 다양하면 응용 서비스에서 반드시 파라미터로 전달받은 값이 올바른지 검사



## 권한 검사
보통 권한 검사를 수행하는 곳
* 표현 영역
* 응용 서비스
* 도메인

표현 영역에서 할 수 있는 가장 기본적인 검사는 인증된 사용자 여부 검사. Servlet filter
권한에 대해서 필터 처리. Spring security
응용 서비스의 메서드 단위로 권한 검사. AOP



## 조회 전용 기능과 응용 서비스
서비스에서 수행하는 추가적인 로직이 없을뿐더러 조회 전용이라 트랜잭션도 필요 X
단순히 조회 전용 기능을 호출하고 끝남

이런 경우라면 굳이 서비스 만들 필요 없이 표현 영역에서 바로 dao 조회 전용 기능을 호출
조회 전용 기능에 대해서는 11장에서 좀 더 자세히





------

# 도메인 서비스

## 여러 애그리거트가 필요한 기능
한 애그리거트에 넣기 애매한 도메인 기능을 특정 애그리거트에서 억지로 구현하면 안된다
이 경우 애그리거트는 자신의 책임 범위를 넘어서는 기능을 구현하기 때문에 코드가 길어지고 외부에 대한 의존이 높아짐
-> 코드를 복잡하게 만들어 수정을 어렵게 만드는 요인

## 도메인 서비스
한 애그리거트에 넣기 애매한 도메인 개념을 구현하려면 도메인 서비스를 이용해서 도메인 개념을 명시적으로 드러내면 됨
도메인 서비스는 상태 없이 로직만 구현. 도메인 서비스를 구현하는 데 필요한 상태는 애그리거트나 다른 방법으로 전달받음

도메인 서비스를 사용하는 주체는 애그리거트가 될 수도 있고, 응용 서비스가 될 수도있음

도메인 서비스는 로직을 수행하지, 응용 로직을 수행하지는 않는다. 트랜잭션 처리와 같은 로직은 도메인 서비스가 아닌 응용 서비스에서 처리해야함.


### 도메인 서비스의 패키지 위치
도메인 구성요소와 동일한 패키지에 위치
도메인 서비스의 개수가 많거나 엔티티나 밸류와 같은 다른 구성요소와 명시적으로 구분하고 싶다면,
Domain 패키지 밑에 하위 패키지를 구분해서 위치시켜도 됨

### 도메인 서비스의 인터페이스와 클래스
도메인 서비스의 로직이 고정되어 있지 않은 경우 도메인 서비스 자체를 인터페이스로 구현하고 이를 구현한 클래스를 둘 수도 있음




------

# 애그리거트 트랜잭션 관리
## 애그리거트와 트랜잭션
개념적으로 동일한 애그리거트이지만 물리적으로 서로 다른 애그리거트 객체를 사용
DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요

## 선점 잠금
먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하는 것을 막는 방식
LockModType.PESSIMISTIC_WRITE

### 선점 잠금과 교착 상태
잠금 순서에 따른 deadlock이 발생하지 않도록 주의해야함
```
1. 스레드1: A 애그리거트에 대한 선점 잠금 구함
2. 스레드2: B 애그리거트에 대한 선점 잠금 구함
3. 스레드1: B 애그리거트에 대한 선점 잠금 시도
4. 스레드2: A 애그리거트에 대한 선점 잠금 시도
```
deadlock은 상대적으로 사용자 수가 많을 때 발생할 가능성이 높고, 사용자 수가 많아지면 교착 상태에 빠지는 스레드가 더 빠르게 증가한다.

이러한 문제 방지를 위해 잠금을 구할 때 최대 대기시간을 지정

DBMS에 따라 커넥션을 처리하는 방식이 다름 (쿼리별로 대기 시간을 지정, 커넥션 단위로만 대기 시간을 지정)
선점 잠금을 사용하려면 사용하는 DBMS에 대해 JPA가 어떤식으로 대기 시간을 처리하는지 반드시 확인!


## 비선점 잠금
변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식
애그리거트에 버전 명시용으로 프로퍼티를 추가하고, 애그리거트 수정할 때마다 해당 값을 +1
JPA에서는 @Version 애노테이션을 이용하여 해당 기능을 사용할 수 있음
쿼리 실행결과로 수정된 행의 개수가 0이면 이미 누군가 앞서 데이터를 수정한 것 => 트랜잭션 충돌한 것이므로 종료 시점에 exception 발생

### 강제 버전 증가
루트 엔티티가 아닌 다른 엔티티의 값만 변경되는 경우,
JPA는 루트 엔티티의 버전 값을 증가하지 않기 때문에 버전 값 갱신이 안됨 (논리적으로는 버전값 갱신이 되는게 맞음)
엔티티를 구할 때 EntityManager#find() 메서드로 강제로 버전 값을 증가시키는 잠금 모드를 지원. LockModeType.OPTIMISTIC_FORCE_INCREMENT
해당 엔티티의 상태가 변경되었는지 여부에 상관없이 트랜잭션 종료 시점에 버전 값 증가!


## 오프라인 선점 잠금
여러 트랜잭션에 걸쳐 동시 변경을 막음

수정 기능은 아래 두 개의 트랜잭션으로 보통 구성
1. 폼을 보여줌 -> 잠금을 선점
2. 데이터를 수정 -> 잠금 해제

수정 요청을 수행하지 않고 사용자가 프로그램을 종료하면, 다른 사용자는 영원히 잠금을 구할 수 없음
-> 잠금 유효시간 설정
잠금 유효시간이 지난 직후 수정 요청이 일어나 수정이 실패하는 케이스가 발생할 수 있기 때문에 일정 주기로 유효시간을 증가시키는 방식도 필요

### 오프라인 선점 잠금을 위한 LockManager 인터페이스와 관련 클래스
1. 잠금 선점 시도
2. 잠금 확인
3. 잠금 해제
4. 락 유효시간 연장

기능을 제공해야함

```java
public interface LockManager {
    //* 잠금 선점 성공하면 LockId를 return
	//* 해당 LockId는 잠금 해제할 때 사용해야하기 때문에 보관
    LockId tryLock(String type, String id) throws LockException;	// 잠글 대상, 식별자
    void checkLock(LockId lockId) throws LockException;
    void releaseLock(LockId lockId) throws LockException;
    void extendLockExpiration(LockId lockId, long inc) throws LockException;
}
```



### DB를 이용한 LockManager 구현
잠금 정보를 저장하기 위한 별도 테이블 생성
type, id, 잠금id, 유효시간

```sql
create table locks (
    type varchar(255),
    id varchar(255),
    lockid varchar(255),
    expiration_time datetime,
    primary key (type, id)
) character set utf8;

create unique index locks_idx ON locks (lockid);
```

