# 리포지터리와 모델 구현

## JPA를 이용한 리포지터리 구현

* 애그리거트를 저장하는 저장소에 따라 리포지터리를 구현하는 방법이 다름
* 만약 RDBMS를 사용한다면 객체 기반 도메인 모델 <-> 관계형 데이터 모델 매핑을 처리하는 기술로 ORM이 좋음
* ORM 표준인 JPA가 있음

### 모듈 위치

* 리포지터리 인터페이스는 도메인 영역, 리포지터리를 구현한 클래스는 인프라스트럭처 영역

### 리포지터리 기본 기능 구현

* 리포지터리의 기본 기능
  * 아이디로 애그리거트 조회하기
  * 애그리거트 저장하기
* 리포지터리 인터페이스는 애그리거트 루트를 기준으로 작성
* findBy같은 네이밍 규칙을 사용
* JPA를 사용하면 트랜잭션 범위에서 변경한 데이터를 자동으로 DB에 반영 (더티체킹)
* 아이디 외에 다른 조건으로 애그리거트를 조회할 때에는 JPA의 Criteria나 JPQL을 사용하면 편하게 조회할 수 있다.

## 매핑 구현

### 엔티티와 밸류 기본 매핑 구현

* JPA 매핑을 위한 기본 규칙은 다음과 같다.
  * 애그리거트 루트는 엔티티이므로 @Entity로 매핑 설정
  * 한 테이블에 ㅇ네티티와 밸류 데이터가 같이 있다면
    * 밸류는 @Embeddable로 매핑 설정
    * 밸류 타입 프로퍼티는 @Embedded로 매핑 설정

### 기본 생성자

* Jpa에서는 DB 데이터를 매핑하여 읽어올 때 기본 class를 상속한 proxy 객체를 생성
* 그렇기 때문에 기본 생성자가 public / protect level로 존재 하여야 한다.

### 필드 접근 방식 사용
* 필드와 메서드의 두가지 방식으로 데이터 매핑을 처리
* 메서드 방식을 사용하기 위해서는 get/set 메서드를 구현해야 함
* 도메인의 의도가 사라질 수 있기 때문에 필드 방식에 접근법을 사용

### 밸류 매핑 처리

* 밸류 타입의 프로퍼티가 한 개 칼럼에 매핑해야 할 때가 있음그럴
* 그러한 경우 jpa에서는 AttributeConverter를 제공해서 db 컬럼 <-> 밸류 타입 간에 변환을 지원

### 밸류 컬렉션 : 별도 테이블 매핑

* 밸류 타입 값을 컬렉션으로 들고 있는 경우가 있음
* 이러한 경우 @ElementCollection 과 @CollectionTable를 함께 사용해 별도 테이블에 밸류 타입 값을 저장한다.
* 한개의 컬럼에 저장하는 방법도 있음 (이걸 쓰는걸까..?)

### 밸류를 이용한 아이디 매핑

* JPA에서는 밸류 타입을 통해 식별자를 지정하는 기능도 제공함
* @EmbeddedId 어노테이션을 활용
* 이러한 방법으로 식별자에게 기능을 추가할 수 있음
* 꼭 equals() / hashcode() 구현 필요

### 별도 테이블에 저장하는 밸류 매핑

* 애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 밸류인 경우가 많다.
* 루트 엔티티 외에 또 다른 엔티티가 잇다면 의심해볼 필요가 있음
* 테이블에 데이터를 저장한다고 해서 엔티티는 아니다.
* 밸류가 아니라면 다른 애그리거트는 아닌지 확인해야 한다.
* 구분하는 방법은 
  * 고유식별자를 가지는지, 별도 테이블로 저장되고 pk가 있다고 해서 테이블과 매핑되는 애그리거트 구성요소가 고유 식별자를 갖는것은 아니다.
  * 독자적인 라이프 사이클을 가짐
* 밸류 데이터를 또다른 테이블로 빼서 저장할 수 있음

### 밸류 컬렉션을 @Entity로 매핑하기

* 개념적으로는 밸류이나 다양한 이유로 @Entity를 사용해야 하는 경우가 있음
* @Embeddable 타입은 클래스 상속 매핑을 지원하지 않기 때문에 @Entity를 사용해야 한다.
* 상속 매핑을 지원하기 위해서 @Discriminator / @DiscriminatorValue 를 사용하여 상속 매핑을 나타낸다.
* 종속적인 라이프 사이클을 cascade 속성을 사용해 표현

### ID 참조와 조인 테이블을 이용한 단방향 M:N 매핑

* 애그리거트간 직접 매핑의 경우 영속성 전파나 로딩 전략을 고민해야 함
* 식별자를 참조하여 이러한 문제를 해결 가능

## 애그리거트 로딩 전략

* JPA 매핑을 설정할 때 애그리거트에 속한 객체가 모두 모여야만 완전한 하나가 된다는 것
* 다만 개념적으로는 하나여야 하지만, 루트 엔티티를 로딩하는 시점에 모두 로딩해야 하는 것은 아니다.
* 실제로 상태 변경시점에 구성 요소만 로딩해도 문제가 되지는 않는다.

## 애그리거트의 영속성 전파

* 애그리거트를 조회할때 뿐만 아니라 저장하고 삭제할때도 애그리거트는 완전한 상태여야 한다.
* 저장/삭제시 애그리거트의 속한 모든 객체가 영향을 받아야 한다.
* 이러한 속성을 영속성전파 기능을통해 설정 가능하다.

## 식별자 생성 기능

* 방법에는 사용자 직접 생성, 도메인 로직으로 생성, DB를 이용한 일련번호 사용이 있다.

# 리포지터리 조회 기능

## 검색을 위한 스펙

* 리포지터리에 애그리거트 검색 조건이 다양해지면 findxxx 메서드가 너무 많아질 수 있다.
* specification 을 이용하여 특정 조건을 충족하는지 여부 검사를 할 수 있다.
* 리포지터리는 스펙을 전달받아 애그리거트를 걸러내는 용도로 사용

### 스펙 조합

* 이러한 스펙은 AND나 OR로 조합이 가능하다.

## JPA를 위한 스펙 구현

* CriteriaBuilder와 Predicate를 이용해서 검색 조건을 구현
* and / or 도 구현 가능
* JPA에서는 JpaSpecificationExecutor 사용하면 편함

## 정렬 구현

* CriteriaQuery#orderBy와 CriteriaBuilder#asc()/desc() 메서드로 정렬 대상 지정

## 페이징과 개수 구하기

* jpql을 사용시 setFirstResult / setMaxResults 메서드를 제공
* PagingAndSortingRepository 를 사용하면 편함

## 조회 전용 기능 구현

* 리포지터리를 여러 애그리거트를 조합해서 보여주거나 통계용으로 사용하기에는 적합하지 않음
* 기능적으로 로딩 전략이나 다양한 기술적 어려움이 있음
* 또한 통계 데이터 역시 쿼리를 표현하기에 어려움이 있음

### 동적 인스턴스 생성

* jpql등을 이용한 조회전용 동적 인스턴스 생성
* 조회 전용 인스턴스 같은 경우 사용자에게 보여주기 위함
* 조회 전용 인스턴스에서는 필요한 값만 전달 받으면 됨
* 장점은 jpql을 그대로 사용하면서 객체 기준으로 쿼리 작성이 가능

### 하이버네이트 @Subselect 사용

* @Subselect는 쿼리 결과를 @Entity로 매핑 가능
* 해당 @Entity는 수정이 불가능함, 수정시 에러가 발생하므로 @Immutable 어노테이션을 사용
* 또한 @Sunchronize 어노테이션을 사용해서 같은 트랜잭션 내부에서 발생한 변경도 적용될 수 있도록 설정할 수 있따.
* 