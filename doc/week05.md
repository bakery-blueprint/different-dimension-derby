# 5주차

## 도메인 모델과 Bounded Context

- DDD 초심자가 빠지기 가장 쉬운 함정은 도메인을 완벽하게 표현하는 단일 모델을 만드는 시도를 하는 것이다.

: 한 개의 모델로 여러 하위 도메인을 모두 표현하려고 시도하게 되면 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.


### Bounded Context(경계를 갖는 컨텍스트)

모델은 특정한 컨텍스트 내에서 완전한 의미를 갖는데, 이렇게 구분되는 경계를 갖는 컨텍스트를 말한다. 

- 논리적으로 한 개의 모델을 갖는다. 

- 도메인 뿐만 아니라 표현, 응용, 도메인, 인프라 영역 등을 모두 포함한다. 

- 각 컨텍스트 마다 서로 다른 기술로 구현할 수 있다. 

- 다른 컨텍스트를 REST API를 통해 직접 통합하거나 메시지 큐를 통해 간적접으로 통합할 수 있다. 


MSA는 Bounded Context를 기반으로 분리하게 된다. 


### Ubiquitous Language(보편 언어), 유비쿼터스 언어 

Ubiquitous Language 보편언어, 공통 언어는 도메인 전문가, 아키텍트, 개발자 등 프로젝트 구성원 모두에게 공유된 언어를 뜻 한다. 

표준 비즈니스 용어나 도메인 전문가들의 은어가 아니다. 커버 영역은 전 세계 공통, 전사 조직 등에서 소화하는 것이 아니라 프로젝트를 수행하는 조직 내부에서만 유효하다.

유비쿼터스 언어(보편 언어) 가 도메인의 의도를 정확히 반영하고 핵심 개념이 잘 표현될 수 있도록 정의해야 한다.

기획자, 개발자 각각 구성원 간 각자의 언어를 사용하는 경우, 의사소통에 비용이 든다. 상대방이 내뱉은 단어를 내가 사용하는 단어로 번역해서 이해해야 하고, 회의 내용을 공유할 때 각자 해석이 분분한 지점에 첨언을 달아야 한다.

모두가 함께 쓰는 공통 언어 + 중의적 의미가 제거된 명확한 언어 + 번역이 필요없는 언어를 추구하자.

Ubiquitous Language는 Bounded Context에서 존재하고 Bounded Context 내에서 보다 명확한 의미를 갖는다. 

### 컨텍스트 통합 

- 직접 결합 API : 다른 컨텍스트 모델을 직접 사용하기 보다는 해당 컨텍스트에 맞게 표현해야 한다. (안티코롭션)
- 간접 결합 MQ : 큐 제공자에 따라서 데이터 구조가 달라진다. 
- 독립 방식 (SEPARATE WAY) : 서로 컨텍스트를 통합, 의존하지 않고 개발하는 방식이다. 수동으로 sync하거나, 통합 시스템을 구축해야 한다. 

### 공개 호스트 서비스 OPEN HOST SERVICE

Bounded Context 어떤 식으로든 연결되고 관계가 형성되고 의존성이 생긴다. 

downstream 컴포넌트는 upstream 컴포넌트의 컨텍스트의 데이터와 기능에 의존한다. 

상류 컴포넌트는 일종의 서비스 공급자 역할을 하며 하류 서비스는 그 서비스를 사용하는 고객 역할을 한다.

서비스 공급자가 마음대로 API를 변경하면 하류 팀은 변경된 API를 맞추느라 우선순위가 높은 다른 기능을 개발하지 못한다. 

상류 컴포넌트는 하류 컴포넌트가 사용할 프로토콜을 정의하고 서비스 형태로 공개한다. 

이런 서비스를 공개 호스트 서비스라고 한다.

- 안티코럽션 게층 (Anti Corruption Layer) : 상류 서비스의 모델이 잔신의 도메일 모델에 영향을 주지 않도록 완충 지대를 말한다. 

### 공유 커널 (SHARED KERNEL) 

다른 Bounded Context 가 동일한 모델이 존재할 경우, 해당 모델을 공유하여 중복 개발을 막을 수 있다.

공유하는 모델을 공유 커널이라고 부른다. 

- 중복을 줄여주는 장점
- 공유하기 때문에 임의로 모델을 변경할 수 없다. 이로 인해 개발이 지연될 수 있다. 


### 컨텍스트 맵 

컨텍스트에 집중하다보면 전체를 보지 못할 때가 있다. 나무를 보다보면 숲을 보지 못한다. 

오픈 호스트 서비스 (OHS), 안티 코럽션 계층(ACL) 표시도 한다. 

따로 규칙은 없고 도형과 선으로 컨텍스트의 관계를 표현하면 된다. 


## 이벤트 

과거에 벌어진 일을 뜻한다. 

이벤트가 발생했다는 것은 상태가 변경됐다는 것을 의미한다. 

### 이벤트의 구성

- 이벤트 종류
- 발생 시간
- 데이터 


## 이벤트 용도 

- 트리거 : 후처리를 위한 용도 
- 동기화 : 서로 다른 시스템 간의 데이터 통기화


### 이벤트 장점 

서로 다른 도메인인 섞이는 것을 방지한다. 

엔티티, 객체 간의 의존성을 없앨 수 있다. 

### 이벤트 단점

흐름을 따라가기 어렵고 분석하기 어렵다 이로 인해 시스템 복잡도가 증가한다. 

### 이벤트, 핸들러, 디스패처 구현 

- 이벤트
- Handler : 이벤트 처리 
- 디스패처 : 이벤트의 디스패치, 발행 , 핸들러 등록, 이벤트 위임 

이벤트 구현을 직접할 수 있지만, 스프링 Event를 사용하면 보다 간단해진다...

### 이벤트 저장소 구현 

이벤트를 DB에 저장하고, 별도의 어플리케이션에서 이벤트를 처리하는 방식 

### 이벤트 고려사항 

- 이벤트 발생시 추가할지 여부 : 이벤트 발생지를 표시하는 것  
- 실패 전략 : 실패할 경우 얼마나 재처리할 것 인가.?
- 이벤트 손실 : 비동기로 처리할 경우 이벤트 유실할 수 있다. 트랜잭션안에서 동기로 처리하면 좋지만 그만큼 트랜잭션이 길어진다.
- 이벤트 순서 : 이벤트 발생 순서대로 처리할 경우를 말한다. 
- 이벤트 재처리 : 동일한 이벤트 처리로 멱등성으로 처리하거나, 이벤트를 데이터, 상태로 관리하여 무시해야 한다. 

## CQRS (Command Query Responsibility Segregation)

데이터 변경 (Command), 데이터 조회 (Query)를 분리하는 것을 말한다. 

복잡한 도메인 모델에서 명령 기능과 조회 기능이 다루는 데이터 범위에 차이가 발생하고 단일 모델로 처리할 경우 

필요 이상으로 복잡해지는 문제가 발생한다. (조회 기능을 위해 JPA 여러 필드를 Eager로 한번에 가져 옴, 캐시 구현)

CQRS는 C / Q 에 각기 다른 구현 기술을 적용할 수 있다. Mybatis / JPA를 각각 사용하는 경우다. 

C / Q 각기 다른 DB 를 사용할 수도 있다. 

C에서 데이터가 변경되면 이벤트가 발생하고 조회 모델에서 반영한다. 

### 장점
- 명령 / 조회 모델에서 서로의 구현을 신경쓰지 않아서 복잡도를 낮춰준다.
- 성능 향상시키는데 도움이 된다. DB 분리도 가능하고 slave read서버도 가능하다. 

### 단점

- 구현할 코드가 너무 많다. 

- 더 많은 구현 기술이 필요하다. 

- 유지보수 비용이 높아진다. 








